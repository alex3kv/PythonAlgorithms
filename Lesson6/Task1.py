'''
Подсчитать, сколько было выделено памяти под переменные в ранее разработанных программах в рамках первых трех уроков. 
Проанализировать результат и определить программы с наиболее эффективным использованием памяти.

Примечание: 
По аналогии с эмпирической оценкой алгоритмов идеальным решением будет:
a. выбрать хорошую задачу, которую имеет смысл оценивать по памяти;
b. написать 3 варианта кода (один у вас уже есть);
проанализировать 3 варианта и выбрать оптимальный;
c. результаты анализа (количество занятой памяти в вашей среде разработки) вставить в виде комментариев в файл с кодом. Не забудьте указать версию и разрядность вашей ОС и интерпретатора Python;
d. написать общий вывод: какой из трёх вариантов лучше и почему.

Надеемся, что вы не испортили программы, добавив в них множество sys.getsizeof после каждой переменной, а проявили творчество, фантазию и создали универсальный код для замера памяти.
'''
import sys

print(sys.version, sys.platform)
'''
3.7.5 (tags/v3.7.5:5c02a39a0b, Oct 15 2019, 00:11:34) [MSC v.1916 64 bit (AMD64)] win32
'''

# функция подсчета размеров переменных
def get_vars_info(loc):
    
    all_size = 0
    result = {}
        
    for var in loc.keys():        
        size = sys.getsizeof(loc[var])
        result.setdefault(var, size)
        all_size += size

    return result, all_size

'''
Оцениваем потребление памяти для задачи (Урок 3 задача 1):
В диапазоне натуральных чисел от 2 до 99 определить, сколько из них кратны каждому из чисел в диапазоне от 2 до 9.
Примечание: 8 разных ответов.
'''

# решение 1
def solution_1():
    result = {}

    for divider in range(2, 10):
        result.setdefault(divider, 0)
        for dividend in range(2, 100):
            if dividend % divider == 0:
                result[divider] += 1
                    
    return result, locals()

# решение 2
def solution_2():
    result = [0, 0, 0, 0, 0, 0, 0, 0]

    for i in range(2, 100):
        for k in range(2, 10):
            if i % k == 0:
                result[k - 2] += 1

    return result, locals()

# решение 3
def solution_3():
    array = [i for i in range(2, 100)]

    result = [0 for _ in range(2, 10)]

    for i in range(2, 10):
        result[i - 2] = (array[len(array) - 1]) // i

    return result, locals()


print()
# считаем решения 1
res1, loc1 = solution_1()
print("Результат решения 1")
print(res1)
print("Используемая память переменных решения 1")   
var_info_1 = get_vars_info(loc1)
print(var_info_1)

print()
# считаем решения 2
res2, loc2 = solution_2()
print("Результат решения 2")
print(res2)
print("Используемая память переменных решения 2")   
var_info_2 = get_vars_info(loc2)
print(var_info_2)

print()
# считаем решения 3
res3, loc3 = solution_3()
print("Результат решения 3")
print(res3)
print("Используемая память переменных решения 3")   
var_info_3 = get_vars_info(loc3)
print(var_info_3)

'''
Результат решения 1
{2: 49, 3: 33, 4: 24, 5: 19, 6: 16, 7: 14, 8: 12, 9: 11}
Используемая память переменных решения 1
({'result': 368, 'divider': 28, 'dividend': 28}, 424)

Результат решения 2
[49, 33, 24, 19, 16, 14, 12, 11]
Используемая память переменных решения 2
({'result': 128, 'i': 28, 'k': 28}, 184)

Результат решения 3
[49, 33, 24, 19, 16, 14, 12, 11]
Используемая память переменных решения 3
({'array': 912, 'result': 128, 'i': 28}, 1068)

Видим, что оптимальным по расходу памяти, является решение 2, 
первое решение занимает больше памяти так как используется словарь для храннения и вычисления результата, 
а в решении 2 использовался список которые занимает меньше памяти, решение 3 неоптмальное так как использует дополнительный список
'''
