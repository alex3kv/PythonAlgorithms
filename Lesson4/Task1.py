'''
Проанализировать скорость и сложность одного любого алгоритма из разработанных в рамках домашнего задания первых трех уроков.
Примечание. Идеальным решением будет:
a. выбрать хорошую задачу, которую имеет смысл оценивать,
b. написать 3 варианта кода (один у вас уже есть),
c. проанализировать 3 варианта и выбрать оптимальный,
d. результаты анализа вставить в виде комментариев в файл с кодом (не забудьте указать, для каких N вы проводили замеры),
e. написать общий вывод: какой из трёх вариантов лучше и почему.
'''
import timeit
import cProfile
import sys
sys.setrecursionlimit(4000)

N = 500

# мое решение
def solution_1(n):
    result = 1

    r = 1
    for _ in range(1, n):
        r *= -0.5
        result += r

    return result

# решение одногрупника
def solution_2(n):
    return 1 if n == 1 else (- 0.5) ** (n - 1) + solution_2(n - 1)

# решение преподавателя
def solution_3(n):
    item = 1
    summa = 0    
    for i in range(n):
        summa += item
        item /= -2        
    return summa

# решение одногрупника с использованием мемоизации
def solution_4(n):
    
    arr = {0:0, 1:1}
    
    def _solution_4(n):

        if n in arr:
            return arr[n]

        arr[n] = (- 0.5) ** (n - 1) + _solution_4(n - 1)

        return arr[n]

    return _solution_4(n)

print(solution_1(N))
print(solution_2(N))
print(solution_3(N))
print(solution_4(N))

cProfile.run(f"solution_1({N})")
cProfile.run(f"solution_2({N})")
cProfile.run(f"solution_3({N})")
cProfile.run(f"solution_4({N})")

'''
               500    1000    2000    3500             
solution_1   0.000   0.000   0.000   0.001   
solution_2   0.001   0.002   0.003   0.006  
solution_3   0.000   0.000   0.000   0.001
solution_4   0.001   0.002   0.004      -

решение 2 и 4 используют рекурсию, запуск функции происходит n-раз для обычного конфига setrecursionlimit = 1000 можно посчитать для n < 1000
время вычисления варианта с рекурсией значительно больше чем в решении 1 и 3, решение 4 для n = 3000 и более не функционирует,
оптимальными решениями являются решение 1 и решение 3, алгоритм у них идентичен, подсчет не ограничен параметром рекурсии, 
скорость расчета значительно выше других решений, памяти будет использоваться меньше так как не храняться данные всех вызываемых функций как в случаях 2 и 4
'''